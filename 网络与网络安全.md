# 1. 网络

# 1.1 http与https

### 1.1.1 状态码

- 200 OK
- 301 永久重定向 新网站 比如，我们访问 **http**://xxx 会跳转到 **https**://xxx
- 302 暂时重定向 比如未登陆的用户重定向到登录页面
- 304 not modified 未修改
- 400 bad request 参数错误
- 401 unauthorized  需要验证
- 403 forbidden 不允许访问 未获得访问授权，无权限
- 404 not found
- 500 服务器错误

### 1.1.2 http报文首部

- http请求报文

报文首部：请求行（Get / HTTP/1.1）、请求首部字段、通用首部字段、实体首部字段

- http响应报文

  报文首部：状态行（HTTP1.1 304 Not Modified）、响应首部字段、通用首部字段、实体首部字段

- 请求首部字段

  Accept、Host、Authorization、Referer、If-Math( ETag )、If-Modified-Since、User-Agent、Cookie

- 响应首部字段

  ETag、Location（重定向至指定URI）、Set-Cookie

- 通用首部字段

  Cache-Control、Connection、Date

- 实体首部字段

  Content-Type、Expires、Last-Modified

### 1.1.3 http的缺点

http的缺点：

1. 通信使用明文会被窃听
2. 不验证通信方的身份
3. 无法证明报文完整性，可能已被篡改（中间人攻击，MITM）

### 1.1.4 https

https：

1. http+SSL/TLS 将通信加密

   混合加密机制（对称加密+非对称加密）

   非对称加密用于交换稍后要用的密钥（加密用公钥、解密用私钥）

   使用对称加密的方式通信（加解密使用同样的密钥）

2. SSL还使用证书，验证对方身份

3. SSL提供摘要功能

4. 缺点：通信慢

过程：

 ![对称加密](https://seminelee.github.io/static/2019/10/https-11.jpg) 

1. 服务器把自己的公钥登陆到CA，CA用自己的私钥向服务器的公开密码署数字签名（对内容做hash然后用私钥加密得到数字签名）并颁发公钥证书，服务器把公钥证书发送给客户端
2. 客户端使用CA公钥对证书的数字签名进行验证（CA私钥加密，可以用CA公钥解密，此为非对称加密），以确认服务器公钥真实性
3. 客户端使用服务器公钥对报文（稍后用到的共享密钥）加密后发送
4. 服务器使用服务器私钥进行解密，得到共享密钥，使用共享密钥加密内容返回给客户端

### 1.1.5 websocket

URL：`ws://xxx` 或 `wss://xxx` 

全双工通信，解决ajax和XMLHttpRquest缺陷（连接发起方只能是客户端），提升Web浏览速度

优点：

1. 支持服务器向客户端推送功能
2. 一直保持连接，头部信息较http小，减少通信量

连接：使用http的头部字段`Upgrade: websocket`

响应：状态码`101 Switching Protocols

## 1.2 浏览器缓存和服务器缓存

### 1.2.1 强缓存

浏览器在规定时间内强制使用浏览器内的缓存（from dish cahe/from memory cache）

响应头部中：

- `Expires`: Thu, 18 Oct 2018 13:28:45 GMT (http1.0)（绝对时间，客户端时间不对就gg）

- `Cache-Control`: max-age=3600 (http1.1) （相对时间）【浏览器优先查看】

如果没有超过规定时间，则使用浏览器缓存，不再次发起请求。

### 1.2.2 协商缓存

与服务器协商是否需要使用浏览器缓存

- `Last-Modified`/`If-Modified-Since`（精确到秒）
 1. 首次请求时，服务器响应，其中头部字段`Last-Modified`为最后修改时间；
  
 2. 再次请求时，请求带上`If-Modified-Since`字段（值为上次返回的`Last-Modified`值），服务器将`If-Modified-Since`与资源的最后修改时间对比，如果没有变化返回304不反悔资源内容，否则200返回新的资源内容
  
 3. 浏览器收到304的响应后，就会从缓存中加载资源；收到200和新的`Last-Modified`值，即下次`If-Modified-Since`的值。


- `ETag`/`If-None-Match`【服务器优先验证】（更精确）

  1. 首次请求时，服务器响应，其中头部`Etag`字段为资源在服务器的唯一标识

  2. 再次请求时，请求带上`If-None-Match`字段（值为上次返回的`Etag`值），服务器检查`If-None-Match`字段，决定返回304或200（同上）
  3. 同上



## 1.3 从输入地址到浏览器渲染页面

[从浏览器中输入网址到网页显示的探索之旅](https://seminelee.github.io/2018/12/15/tcp/)

### 1.3.1 浏览器（应用层）

浏览器根据http协议生成请求消息

然后向DNS服务器查询Web服务器的IP地址（使用udp协议）

P.S.https还会经过SSL/TLS处理

### 1.3.2 TCP（传输层）

操作系统的协议栈的TCP模块通过TCP协议发送消息，最后加上TCP头部（双方端口号、ACK号、控制位等）

1. 创建套接字（存放接收方的ip地址端口号、状态等，可通过`netstat`查看）
2. 建立连接，交换双方端口号等控制信息（三次握手：发送客户端和服务器ip地址和端口号，控制位字段中SYN:1；服务器接收信息，对应套接字写入信息，SYN:1ACK:1；客户端更新状态`established`ACK:1）
3. 收发数据，对较大的数据进行拆分，使用`ACK`字段确认是否收到网络包（接收方收到网络包时，把目前收到总长度写入`ACK`字段，发送方根据`ACK`字段来确定应该发送序号为多少的数据包）
4. 断开连接（四次挥手：发起方设置控制位中`FIN`为1，改变套接字状态；接收方改变套接字状态，发送`FIN`:1`ACK`:1；接收方__等到收到所有数据__后，确认能断开连接，发送`FIN`:1；发起方返回`ACK`:1）

### 1.3.3 IP（网络层）

协议栈的IP模块加上IP头部（ip地址等）和MAC头部（MAC地址）

- IP头部

  接收方IP地址（TCP模块告知的）、发送方IP地址（通过路由表得到应该从哪一个网关发送）

- MAC头部

  包括接收方的MAC地址和发送方的MAC地址等。

  以太网在判断网络包目的地时和TCP/IP的方式不同，需要知道MAC地址才能在以太网中将包发往目的地。

  在以太网中，我们可以通过广播的方法把包发给同一个子网中的所有设备。ARP协议利用广播得到MAC地址（一个个子网逐级查找）。

### 1.3.4 数据链路层和物理层

网卡（网关）接收到网络包之后，就会把IP模块生成的网络包转换成电或光信号，这样就在网线上传输了。

### 1.3.5 浏览器渲染

请求到达服务器，响应返回浏览器。浏览器会根据http头部的Content-Type字段、文件扩展名等判断数据类型，然后将数据显示出来。

### 1.3.6 cdn原理

利用内容分发服务分担负载，从最近的缓存服务器中返回，提升页面响应速度。

怎么找到最近的缓存服务器？

- 用DNS服务器分配访问：

  1. 服务器端DNS服务器事先从各地路由器收集路由信息
  2. 客户端DNS服务器请求DNS服务器，服务器端DNS服务器根据路由表和客户端ip估算各个服务器到客户端的距离
  3. 比较得出。

  P.S.但是客户端的DNS服务器不一定与客户端在同一位置，所以有偏差

- 通过重定向服务器分配

  重定向服务器注册到服务器端DNS服务器上，收集各个路由器的路由信息，找到最近的缓存服务器，把ip地址放到`Location`字段返回。




# 2. 网络安全

## 2.1 常见攻击方式

### 2.1.1 xss

XSS（Cross Site Scripting），全称跨站脚本攻击，即一种允许恶意web用户将代码植入到网站页面中的漏洞，是代码注入的一种。常见于论坛、留言板、邮件中的恶意链接等。

防御措施：

- 输入检查和输出检查。使用过滤函数、转义、或开源的校验组件。

- 服务器响应头部`set-cookie`字段中设置`httponly`属性，则不能使用 JavaScript 经由`document.cookie`、`XMLHttpRequest`和Request APIs访问cookie，以防范XSS后的Cookie挟持攻击。
- 加入验证码校验避免恶意脚本

### 2.1.2 csrf

CSRF（Cross Site Request Forgery），跨站点请求伪造。网站过分信任用户，放任伪造的合法用户的请求执行网站的某些功能。

防御措施：

- 服务端校验`referer`字段
- 请求参数中或者请求头部中加入token字段并校验
- 加入验证码校验避免恶意脚本

### 2.1.3 sql注入

接口校验参数格式、使用过滤函数、转义等

### 2.1.4 DDos

DDOS是（Distributed Denial of Service）的缩写，即分布式阻断服务，黑客利用DDOS攻击器控制多台机器同时攻击来达到“妨碍正常使用者使用服务”的目的。

防御措施：

- 静态资源放到cdn
- 被攻击时，如果被攻击的目标只是ip，修改对应ip地址



# 3 登录相关

## 3.1 cookie与localstorage/sessionStorage区别

| 特性         | Cookie                                                       | localStorage                           | sessionStorage                             |
| ------------ | ------------------------------------------------------------ | -------------------------------------- | ------------------------------------------ |
| 数据的周期   | 服务器生成，可设置失效时间。浏览器生成，关闭浏览器失效       | 除非被清除，否则永久保存               | 仅在当前会话有效，关闭页面或浏览器后被清除 |
| 存放数据大小 | 4KB                                                          | 一般 5MB                               | 一般 5MB                                   |
| 与服务端通信 | 每次都会携带在HTTP头中，如果使用 cookie 保存过多数据会带来性能问题 | 仅在客户端中保存，不参与和服务器的通信 |                                            |
| 用途         | 一般由服务器端生成，用于标识用户身份                         | 用于浏览器端缓存数据                   | 同左                                       |

## 3.2 cookie与session

session：由于http协议本身是无状态的，因此协议本身是不支持“登录状态”这样的概念的，必须由项目自己来实现。

- session首先是一个抽象的概念，指代多个有关联的http请求所构成的一个会话。
- session常常用来指代为了实现一个会话，需要在客户端和服务端之间传输的信息。这些信息可以是会话所需的所有内容（包括用户身份、相关数据等），也可以只是一个id，让服务端可能从后台检索到相关数据，这也是实际系统中最常用的方式。

 session 可以存放在

1. 内存
2. cookie本身
3. redis 或 memcached 等缓存中
4. 数据库中

线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题，容易被篡改和窃取。 

**但是这不意味着我们不需要cookie了，由于http协议的无状态特性，我们依然需要通过cookie来获取session的标识(sessionid)。**然后再通过sessionid去上述的缓存/数据库中查找，获取用户的信息（session）。

## 3.3 实现密码登录

[密码登录实现总结](https://seminelee.github.io/2019/10/14/https/ )

1. 使用https协议（非对称加密+对称加密），详细见1.1.4。

2. 对于密码字段，使用RSA（非对称加密）。客户端使用公钥进行加密后再传给服务端解密。

   https虽然安全，但也有可能被绕过，如在看到警告时用户点击继续浏览此网站还是会被攻击成功。所以对于密码字段还是需要再加密。公钥放在客户端。

3. 单向加密存储密码到数据库。服务端拿到客户端传来的密码字段，解密后用同样的单向加密方式加密，然后与数据库中的密码比对。如果一致，则密码正确。

   单向加密的方式一般有md5加盐（一个随机的字符串）；或者用BCrypt等算法增加破解难度， BCrypt最大的特点是我们可以通过参数设置重复计算的次数 。

4. 验证通过， 需要生成一个登录态，并设置cookie。

   一般来说把用户id作为sessionid设置到cookie中。但直接把用户id放到cookie中容易被窃取和假冒，所以可以使用生成唯一key的算法如uuid（考虑到sessionid的一致性）生成sessionid。

   sessionid与userid的对应关系存入redis 或 memcached 等缓存中（比较快）。这里注意设置sessionid的有效期。

   同一个useid可以有多个sessionid。这使用户可以同时在多个设备上登录。（还可以记录ip，设置异地登录告警）。

5. 设置cookie的属性。一般需要设置

   - `domain`、`path`（作用域）； 
   - 过期时间（`Expires`）或有效期（`Max-Age`） ； 
   - `Secure`（https才能使用）和`HttpOnly` （js无法访问cookie）； 
   - `SameSite ` 允许服务器要求某个cookie在跨站请求时不会被发送 

   >  标记为 `Secure` 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。 
   >
   >  为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 `HttpOnly` 标记的Cookie，它们只应该发送给服务端。 

6. 返回给客户端，客户端之后每次请求都带上cookie，服务端每次请求都校验cookie，得到用户id，再通过用户id获取用户信息以鉴权。

## 3.4 多种登录方式

在上述的基础上增加些变化：

1. 数据库中用用户id作为主key，电话、自定义账号、QQ号等作为unique key
2. 对对应的用户id生成sessionid，设置同名的cookie
3. 后续校验获取用户id，即可获取各种用户信息和权限数据。

## 3.5 单点登录

[什么是单点登录(SSO)]( https://juejin.im/post/5cdd42f9518825693f1ebf8d )

单点登录的英文名叫做：Single Sign On（简称**SSO**） 。传统的系统都是所有的功能都在同一个系统上，而一些系统为了合理利用资源和降低耦合性，于是把单系统拆分成多个子系统。而实现**在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录，** 就是单点登录。

比如阿里系的**淘宝和天猫**，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。 

### 3.5.1 用户信息共享问题

Session不共享问题详细可以看[Session不共享问题]( https://juejin.im/post/5cdd42f9518825693f1ebf8d )

### 3.5.2 cookie跨域问题

**由于域名不同**，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。

针对Cookie存在跨域问题，有几种解决方案：

1. 服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了

2. 多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。

   如下面的例子，所有满足 `*.mycompany.com` 的域名都可以结构该 Cookie，并获取 JWT。

   ```c
   Set-Cookie: jwt=lll.zzz.xxx; HttpOnly; max-age=980000; domain=.mycompany.com
   ```

3. 将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）

### 3.5.3 JWT

JWT（Json Web Token）的__格式__：

- header 部分。包括类型声明、加密算法。
- payload 部分。存放有效信息。
- 签名部分。服务器利用头部的加密算法和私钥对头部和载荷部分的信息进行加密。



客户端收到服务器返回的 JWT，可以

1. 储存在 Cookie 里面，也可以储存在 localStorage。
2. 更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。

> ```javascript
> Authorization: Bearer <token>
> ```

3. 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

可以用于实现单点登录。



__特点&缺点：__

1. **更多的空间占用。**如果将原存在服务端session中的各类信息都放在JWT中保存在客户端，可能造成JWT占用的空间变大，需要考虑cookie的空间限制等因素，如果放在Local Storage，则可能受到XSS攻击。
2. **更不安全。**这里是特指将JWT保存在Local Storage中，然后使用Javascript取出后作为HTTP header发送给服务端的方案。在Local Storage中保存敏感信息并不安全，容易受到跨站脚本攻击，跨站脚本（Cross site script，简称xss）是一种“HTML注入”，由于攻击的脚本多数时候是跨域的，所以称之为“跨域脚本”，这些脚本代码可以盗取cookie或是Local Storage中的数据。可以从这篇文章查看 [XSS攻击](http://www.cnblogs.com/luminji/archive/2012/05/22/2507185.html)的原理解释。
3. **无法作废已颁布的令牌。**所有的认证信息都在JWT中，由于在服务端没有状态，即使你知道了某个JWT被盗取了，你也没有办法将其作废。在JWT过期之前（你绝对应该设置过期时间），你无能为力。
4. **不易应对数据过期。**与上一条类似，JWT有点类似缓存，由于无法作废已颁布的令牌，在其过期前，你只能忍受“过期”的数据。

## 3.6 oAuth

OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。比如QQ登录等。

## 3.7 小程序的登录机制

https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html

![img](https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg)

其实过程与上面说的cookie+session的登录方式、oAuth的登录方式是差不多的。