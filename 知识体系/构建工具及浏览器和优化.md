# 8. webpack

## 8.1 介绍

*webpack* 是一个现代 JavaScript 应用程序的*静态模块打包器(module bundler)*。当 webpack 处理应用程序时，它会递归地构建一个*依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 *bundle*。

四个**核心概念**：

- 入口(entry) 

  构建其内部*依赖图*的开始

- 输出(output) 

  在哪里输出它所创建的 *bundles*，以及如何命名这些文件

- loader 

  让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript），将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。

- 插件(plugins) 插件可以用来处理各种各样的任务，包括：打包优化（tree-shaking）、压缩、重新定义环境中的变量。

## 8.2 配置

``` js
module.exports = {
  // 生成*.map文件，用于追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置
  devtool: shouldUseSourceMap ? 'source-map' : false,
  // 入口，是模块构建的起点，同时每一个入口文件对应最后生成的一个chunk。
  // polyfills和app code
  entry: [require.resolve('./polyfills'), paths.appIndexJs],
  // 生成文件，是模块构建的终点，包括输出文件与输出路径。
  output: {
    path: paths.appBuild,
    filename: 'static/js/[name].[chunkhash:8].js',
    chunkFilename: 'static/js/[name].[chunkhash:8].chunk.js',
    publicPath: publicPath,
    // ...
  },
  // 模块解析
  resolve: {
    // 决定如何查找模块。node_modules优先
    modules: ['node_modules', paths.appNodeModules],
    extensions: ['.web.js', '.mjs', '.js', '.json', '.web.jsx', '.jsx'],
    alias: {
      'react-native': 'react-native-web',
    },
    // ...
  },
  // 这里配置了处理各模块的 loader
  module: {
    rules: [
      // 首先，运行linter。这需要在babel编译前运行。
      {
        test: /\.(js|jsx|mjs)$/,
        enforce: 'pre',
        use: [
          {
            options: {
              formatter: eslintFormatter,
              eslintPath: require.resolve('eslint'),
              
            },
            loader: require.resolve('eslint-loader'),
          },
        ],
        include: paths.appSrc,
      },
      {
        // "oneOf"遍历loaders直到某一个匹配到. 否则使用"file" loader
        oneOf: [
          // "url" loader跟file loader类似，但它以data URLs形式嵌入以避免请求
          {
            test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
            loader: require.resolve('url-loader'),
            options: {
              limit: 10000,
              name: 'static/media/[name].[hash:8].[ext]',
            },
          },
          // babel
          {
            test: /\.(js|jsx|mjs)$/,
            include: paths.appSrc,
            loader: require.resolve('babel-loader'),
            options: {
              
              compact: true,
            },
          },
          // The notation here is somewhat confusing.
          // "postcss" loader 应用 autoprefixer
          // "css" loader 解析css中的路径并将资产作为依赖项添加。
          // "style" loader 将<style>内的css转为js
          {
            test: /\.css$/,
            loader: ExtractTextPlugin.extract(
              Object.assign(
                {
                  fallback: {
                    loader: require.resolve('style-loader'),
                    // ...
                  },
                  use: [
                    {
                      loader: require.resolve('css-loader'),
                      // ...
                    },
                    {
                      loader: require.resolve('postcss-loader'),
                      // ...
                    },
                  ],
                },
                // ...
              )
            ),
          },
          {
            loader: require.resolve('file-loader'),
            exclude: [/\.js$/, /\.html$/, /\.json$/],
            options: {
              name: 'static/media/[name].[hash:8].[ext]',
            },
          }
        ],
      },
    ],
  },
  plugins: [
    // 生成index.html并插入script标签
    new HtmlWebpackPlugin({
      inject: true,
      template: paths.appHtml,
      minify: {
        // ...
      },
    }),
    // 压缩
    new webpack.optimize.UglifyJsPlugin({
      // ...
      sourceMap: shouldUseSourceMap,
    }),
    // 生成manifest文件，内含所有静态资源文件到相应输出文件的映射
    // 无论你选择哪种模块语法，那些 import 或 require 语句现在都已经转换为 __webpack_require__ 方法。webpack 通过 manifest，可以追踪所有模块到输出 bundle 之间的映射。
    new ManifestPlugin({
      fileName: 'asset-manifest.json',
    }),
    // 生成service worker文件，离线或网络不好的情况下使用缓存，PWA使用
    new SWPrecacheWebpackPlugin({
      // ...
    }),
    // ...
  ],
  // 一些库导入节点模块，但在浏览器中不使用它们。告诉Webpack为它们提供空的模拟，以便导入它们。使最初为 Node.js 环境编写的代码，在其他环境（如浏览器）中运行。
  node: {
    dgram: 'empty',
    fs: 'empty',
    net: 'empty',
    tls: 'empty',
    child_process: 'empty',
  },
}
```



## 8.3 基本流程与原理

### 8.3.1 具体流程

1. `entry-option` 初始化option
2. `run` 开始编译
3. `make` 从entry开始递归的分析依赖，对每个依赖模块进行build
4. `before-resolve` - `after-resolve` 对其中一个模块位置进行解析
5. `build-module` 开始构建 (build) 这个module,这里将使用文件对应的loader加载
6. `normal-module-loader` 对用loader加载完成的module(是一段js代码)进行编译,用 [acorn](https://github.com/ternjs/acorn) 编译,生成ast抽象语法树。
7. `program` 开始对ast进行遍历，当遇到require等一些调用表达式时，触发`call require`事件的handler执行，收集依赖，并。如：AMDRequireDependenciesBlockParserPlugin等
8. `seal` 所有依赖build完成，下面将开始对chunk进行优化，比如合并,抽取公共模块,加hash
9. `bootstrap` 生成启动代码
10. `emit` 把各个chunk输出到结果文件

### 8.3.2 内部依赖图

进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

如何查找这些`require`/`import` 语句？

用正则？如果`require`写在注释里也会匹配到；`require('a'+'b')`类似的表达式正则难以处理

因此，使用js代码解析工具**（**如`esprima`或者`acorn`，webpack[Parser.js](https://github.com/webpack/webpack/blob/master/lib/Parser.js)用的是[`acorn`](https://github.com/acornjs/acorn)。），将JS代码转换成抽象语法树（AST），再对AST进行遍历，找出`require`表达式，收集依赖，构造依赖图。

> JavaScriptCore：
> 源代码=>抽象语法树=>字节码
>
> V8：目的提高性能。
> 源代码=>抽象语法树=>本地码 

github上找到的一个webpack伪码[parse.js](https://github.com/youngwind/fake-webpack/blob/1bfcd0edf1/lib/parse.js)

### 8.3.3 模块解析(module resolution)

resolver 是一个库(library)，用于帮助找到模块的绝对路径。

resolver 帮助 webpack 找到 bundle 中需要引入的模块代码，这些代码在包含在每个 `require`/`import` 语句中。 

当打包模块时，`webpack` 使用 [enhanced-resolve](https://github.com/webpack/enhanced-resolve) 来解析文件路径（绝对路径/相对路径/模块路径）。

```js
const resolve = require("enhanced-resolve");

resolve("/some/path/to/folder", "module/dir", (err, result) => {
	result; // === "/some/path/node_modules/module/dir/index.js"
});
```

- 相对路径

  ``` js
  import '../src/file1'
  ```

  在这种情况下，使用 `import` 或 `require` 的资源文件所在的目录，被认为是上下文目录(context directory)。在 `import/require` 中给定的相对路径，会拼接此上下文路径(context path)，以产生模块的绝对路径。

- 模块路径

  ``` js
  import 'module';
  import 'module/lib/file';
  ```

  模块将在 [`resolve.modules`](https://webpack.docschina.org/configuration/resolve/#resolve-modules) 中指定的所有目录内搜索。 你可以替换初始模块路径，此替换路径通过使用 [`resolve.alias`](https://webpack.docschina.org/configuration/resolve/#resolve-alias) 配置选项来创建一个别名。

### 8.3.4 manifest

- 为什么会有manifest.xxx.js？（也有可能打包到main.xxx.js中？）

在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：

1. 你或你的团队编写的源码。
2. 你的源码会依赖的任何第三方的 library 或 "vendor" 代码。
3. webpack 的 runtime 和 *manifest*，管理所有模块的交互。

runtime，以及伴随的 manifest 数据，主要是指：在浏览器运行时，webpack 用来连接模块化的应用程序的所有代码。

一旦你的应用程序中，形如 `index.html` 文件、一些 bundle 和各种资源加载到浏览器中，会发生什么？你精心安排的 `/src` 目录的文件结构现在已经不存在，所以 webpack 如何管理所有模块之间的交互呢？这就是 manifest 数据用途的由来

> create-react-app打包中的`manifest.json`用于service worker（预缓存，应付网络差或断网的情况）

### 8.3.5 模块热替换(hot module replacement)

模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除[模块](https://www.webpackjs.com/concepts/modules/)，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：

- 保留在完全重新加载页面时丢失的应用程序状态。
- 只更新变更内容，以节省宝贵的开发时间。
- 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。

过程：

1. 应用程序代码要求 HMR runtime 检查更新。

2. HMR runtime（异步）下载更新，然后通知应用程序代码。

   - 更新后的 [manifest](https://www.webpackjs.com/concepts/manifest)(JSON)

   - 一个或多个更新后的 chunk (JavaScript)

3. 应用程序代码要求 HMR runtime 应用更新。

4. HMR runtime（同步）应用更新。

### 8.3.6 dllPlugin和external插件

webpack中[`DllPlugin`](https://webpack.js.org/plugins/dll-plugin/#root)和[`externals`]()在本质上其实是解决的同一个问题：避免将某些外部依赖库打包进我们的业务代码，而是在运行时提供这些依赖。

DllPlugin

- 符合前端模块化的要求
- webpack配置上稍微复杂一些，需要预打包所需的dll资源，并在构建时配置相应的plugin
- 使用dll的前提是，这些外部依赖一般不需要发生变更。所以，如果某天发生了变更，那就需要将项目重新构建，比较麻烦。
- 注意`manifest.json`命名冲突

external

- 不太符合前端的模块化思想，所需要的外部库需要在浏览器全局环境下可访问
- 外部库升级的话，如果兼容之前的API，不需要项目重新构建，只需要更新链接
- webpack配置上稍微简单些，但是同样需要将所需的外部库打包为所需要的格式，并在运行态下引用（如果module有提供cdn地址可以直接使用）

### 8.3.7 代码分割

常用的代码分离方法有三种：

- 入口起点：使用 entry 配置手动地分离代码。

- 防止重复：使用` SplitChunksPlugin` 去重和分离 chunk。

  `SplitChunksPlugin`  其中的`maxSize`配置可以解决某个chunk特别大的问题。

- 动态导入：通过模块中的内联函数调用来分离代码。(使用react-loadable 动态加载组件实现组件懒加载）

### 8.3.8 tree shaking

*tree shaking* 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的[静态结构特性](http://exploringjs.com/es6/ch_modules.html#static-module-structure)，例如 [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 和 [`export`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export)。

新的 webpack 4 正式版本，扩展了这个检测能力，通过 `package.json` 的 `"sideEffects"` 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。

要使用tree-shaking，需要做到以下：

- 使用 ES2015 模块语法（即 `import` 和 `export`）。

- 确保没有 compiler 将 ES2015 模块语法转换为 CommonJS 模块（这也是流行的 Babel preset 中 @babel/preset-env 的默认行为 - 更多详细信息请查看 [文档](https://babel.docschina.org/docs/en/babel-preset-env#modules)）。

- 在项目 `package.json` 文件中，添加一个 "sideEffects" 属性。

  表明项目中的哪些文件是 "pure(纯的 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。

  antd的package.json

  ``` json
  {
    // ...
    "sideEffects": [
      "dist/*",
      "es/**/style/*",
      "lib/**/style/*",
      "*.less"
    ],
    // ...
  }
  ```

- 通过将 `mode` 选项设置为 [`production`](https://webpack.docschina.org/concepts/mode/#mode-production)，启用 minification(代码压缩) 和 tree shaking。

  

### 8.3.9 加快首屏渲染/减少代码体积？

 1.code splitting（分入口多页应用、splitChunks防止重复、动态导入）

 3.tree shaking

 4.将不常更新的模块单独打包（dllPlugin），或者放到cdn（externals）

 5.Nginx配置gzip 

 6.SSR（服务端渲染）

# 9. 构建工具

## 9.3 yarn

- 速度快：缓存每个下载的包，并行安装
- 安全性：执行代码前会通过算法校验每个安装包的完整性
- 可靠性：yarn.lock文件记录安装的模块的版本号，保证不同系统上的无差异工作



# 10. 优化策略

## 10.1 浏览器渲染优化

### 10.1.1 浏览器渲染原理

__浏览器内核__

浏览器内核主要分为两部分：**渲染引擎**(layout engineer 或者 Rendering Engine)和 **JS 引擎**。

- 渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，将页面内容和排版代码转换为用户所见的视图。
- JS 引擎则是解析 Javascript 语言，后来 **JS 引擎越来越独立，内核就倾向于只指渲染引擎**。

主流浏览器：

1、IE浏览器内核：Trident内核，也被称为IE内核；

2、Chrome浏览器内核：Chromium内核 → Webkit内核 → Blink内核；

3、Firefox浏览器内核：Gecko内核，也被称Firefox内核；

4、Safari浏览器内核：Webkit内核；



__浏览器多线程__

浏览器的内核是多线程的。

在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

- GUI 渲染线程（渲染引擎）
- JavaScript引擎线程（JS引擎）
- 定时触发器线程：通过单独线程来计时并触发定时，把回调函数放到异步事件队列中
- 事件触发线程：当一个事件被触发时该线程会把回调函数放到异步事件队列中
- 异步http请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到异步事件队列中

其中，GUI 渲染线程 与 JavaScript引擎线程是__互斥__的！

因为JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。所以JavaScript文件加载会阻塞DOM树的构建

> 在事件循环中，由于js线程是单线程，如鼠标点击、AJAX异步请求等这些事件都得排队等待JS引擎处理。定时触发器线程、事件触发线程和异步http请求线程各自处理后会把把回调函数放到事件队列当中。



__渲染过程__

![img](https://images2015.cnblogs.com/blog/746387/201704/746387-20170407181220066-2064922697.png)

1. 浏览器从网络或硬盘中获得HTML字节数据后将字节解析为DOM树

2. 浏览器解析遇到`<link>`标签时，浏览器就开始解析CSS，像构建DOM树一样构建CSSOM树。

3. 在构建了DOM树（文档结构和内容）和CSSOM树（对应文档的样式规则）之后，浏览器将DOM树、CSSOM树结合在一起，构建渲染树。

4. 渲染树构建好后，浏览器得到了每个节点的内容与样式，下一步就是需要计算每个节点在浏览器窗口的确切位置与大小，即layout布局。

5. 当Layout布局完成后，浏览器会立即发出Paint事件，开始将渲染树绘制成像素，绘制所需要的时间跟CSS样式的复杂度成正比，绘制完成后，用户才能看到页面在屏幕中的最终呈现效果。

6. 当解析过程中遇到`<script>`标签的时候，便会停止解析过程，转而去处理脚本，如果脚本是内联的，浏览器会先去执行这段内联的脚本，如果是外链的，那么先会去加载脚本，然后执行。在处理完脚本之后，浏览器便继续解析HTML文档。这也对应了上面说的，GUI 渲染线程 与 JavaScript引擎线程是__互斥__的。

   同时javascript的执行会受到标签前面样式文件的影响。如果在标签前面有样式文件，需要样式文件加载并解析完毕后才执行脚本。这是因为javascript可以查询对象的样式。

   > 这里需要注意一点，在现在浏览器中，为了减缓渲染被阻塞的情况，现代的浏览器都使用了猜测预加载。当解析被阻塞的时候，浏览器会有一个轻量级的HTML（或CSS）扫描器（scanner）继续在文档中扫描，查找那些将来可能能够用到的资源文件的url，在渲染器使用它们之前将其下载下来。

__`DOMContentLoaded`和`load`__

- `DOMContentLoaded`：

  在这里我们可以明确`DOMContentLoaded`所计算的时间，当文档中没有脚本时，浏览器解析完文档便能触发 `DOMContentLoaded `事件；如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等位于脚本前面的css加载完才能执行。在任何情况下，`DOMContentLoaded `的触发不需要等待图片等其他资源加载完成。

- `load`：

  页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件，简单来说，页面的load事件会在DOMContentLoaded被触发之后才触发。

我们在 jQuery 中经常使用的 `$(document).ready(function() { // ...代码... });` 其实监听的就是 `DOMContentLoaded` 事件，而 `$(document).load(function() { // ...代码... });` 监听的是 `load` 事件。

**为什么一再强调将css放在头部，将js文件放在尾部**

在面试的过程中，经常会有人在回答页面的优化中提到将js放到body标签底部，原因是因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。

![img](https://images2015.cnblogs.com/blog/746387/201704/746387-20170407181912191-1031407943.png)

我们再来看一下chrome在页面渲染过程中的，绿色标志线是First Paint的时间。纳尼，为什么会出现firstpaint，页面的paint不是在渲染树生成之后吗？其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。

### 10.1.2 优化

__优化渲染__

- 优化JS：JavaScript文件加载会阻塞DOM树的构建，可以给`<script>`标签添加异步属性async，或放在`<body>`的最底部，这样浏览器的HTML解析就不会被js文件阻塞。

- 优化CSS：浏览器每次遇到`<link>`标签时，浏览器就需要向服务器发出请求获得CSS文件，然后才继续构建DOM树和CSSOM树，可以合并所有CSS成一个文件，减少HTTP请求，减少关键资源往返加载的时间，优化渲染速度。

- 压缩文件（html、css、js）
- 图片加载优化（雪碧图、懒加载、tinypng）
- 加快首屏渲染，减小bundle文件（依赖包）体积。通过：external把较小可能更新的文件放到cdn外部引入；代码分割：页面/组件懒加载分成几个较小文件。



__服务端参与优化__

- 利用浏览器缓存（强缓存、协商缓存）
- cdn分布式存储
- SSR服务端渲染，避免ajax请求过慢
- gzip压缩



## 10.2 小程序优化

- 控制小程序包的大小：压缩代码；图片cdn；分包策略
- 请求优化：利用缓存；先反馈，再请求；合并请求
- 提升渲染性能：减少setData次数；防抖函数；